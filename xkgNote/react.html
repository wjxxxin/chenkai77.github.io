<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>React</title>
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <link rel="icon" href="images/titleIcon/react.jpg">
    <link rel="stylesheet" href="css/cssreset.css">
    <link rel="stylesheet" href="css/androidstudiokai.css">
    <link rel="stylesheet" href="css/page.css">
    <link rel="stylesheet" href="css/cssphone.css" media="(max-width:640px)">
</head>
<body>
<ul class="navLeft">

</ul>
<ul class="navRight">

</ul>
<div class="top">
    框架、工具
</div>
<div class="search">
    <input type="text" placeholder="Search...">
    <div class="searchBut"></div>
    <div class="searchup">↑</div>
    <div class="searchdown">↓</div>
</div>
<div class="phone-show pc-hide titleNav">
    <input type="text" placeholder="搜索">
    <div class="ssbut ss">搜索</div>
    <div class="ssbut ok">ok</div>
    <div class="ssbut sd">下一个</div>
    <div class="alltitle">导航</div>
</div>
<p class="phone-hide" id="githubBox"></p>
<div class="frameTitle">
    <div class="frameItem">jQuery</div>
    <div class="frameItem">Vue</div>
    <div class="frameItem">React</div>
    <div class="frameItem">tool</div>
</div>
<article>
    <div class="item">
        <h3>React 基本</h3>
        <section>
            <div class="small">
                <h4>虚拟DOM</h4>
                <p>虚拟DOM就是为了解决浏览器性能问题而被设计出来的。</p>
                <h5 class="subtitle">描述DOM</h5>
                <pre class="text1"><code class="js"></code></pre>
            </div>
            <div class="small">
                <h4>Diff算法</h4>
                <ol>
                    <li>tree diff:新旧DOM树，逐层对比的方式，就叫做 tree diff,每当我们从前到后，把所有层的节点对比完后，必然能够找到那些 需要被更新的元素；</li>
                    <li>component diff：在对比每一层的时候，组件之间的对比，叫做 component diff;当对比组件的时候，如果两个组件的类型相同，则暂时认为这个组件不需要被更新，如果组件的类型不同，则立即将旧组件移除，新建一个组件，替换到被移除的位置；</li>
                    <li>element diff:在组件中，每个元素之间也要进行对比，那么元素级别的对比，叫做 element diff；</li>
                    <li>key：key这个属性，可以把 页面上的 DOM节点 和 虚拟DOM中的对象，做一层关联关系； 在开发过程中，我们需要保证某个元素的key在其统计元素中具有唯一性。在React Diff算法中React会借助元素的Key值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外React还需要借助key值来判断元素与本地状态的关联关系。</li>
                </ol>
                <img src="images/react/Diff.png" alt="">
            </div>
            <div class="small">
                <h4>基础语法</h4>
                <ol>React.createElement() 方法，用于创建 虚拟DOM 对象，它接收 3个及以上的参数
                    <li>参数1： 是个字符串类型的参数，表示要创建的元素类型</li>
                    <li>参数2： 是一个属性对象，表示创建的这个元素上，有哪些属性 </li>
                    <li>参数3： 从第三个参数的位置开始，后面可以放任意虚拟DOM对象，表示当前元素的子节点</li>
                </ol>
                <pre><code class="js">var myH1 = React.createElement('h1', null, '这是一个大大的H1')
var myDiv = React.createElement('div', { title: 'this is a div', id: 'mydiv' }, '这是一个div', myH1)</code></pre>
                <p>ReactDom里面主要封装了和 DOM 操作相关的包，比如，要把 组件渲染到页面上或者卸载组件等等；用 ReactDOM 把元素渲染到页面指定的容器中</p>
                <pre><code class="js">ReactDOM.render(虚拟DOM或组件,显示的位置)
ReactDOM.render(myDiv, document.getElementById('app'))</code></pre>
            </div>
            <div class="small">
                <h4>JSX语法</h4>
                <p>JSX内部还是以 React.createElement的形式来实现的</p>
                <p>编译原理：当 编译引擎，在编译JSX代码的时候，如果遇到了&lt;那么就把它当作 HTML代码去编译，如果遇到了 {} 就把 花括号内部的代码当作 普通JS代码去编译；</p>
                <ol>
                    <li>在JSX中，如果要为元素添加class属性了，那么，必须写成className，因为 class在ES6中是一个关键字；和class类似，label标签的 for 属性需要替换为 htmlFor.</li>
                    <li>在JSX创建DOM的时候，所有的节点，必须有唯一的根元素进行包裹；</li>
                    <li>如果要写注释了，注释必须放到 {} 内部。单行注释要记得换行。多行注释则不需要。而且这个问题不需要大家格外注意。因为有快捷键 ctrl+?可以快速实现 {/**/}多行注释。</li>
                </ol>
                <pre class="text2"><code class="js"></code></pre>
            </div>
        </section>
    </div>
    <div class="item">
        <h3>React 组件</h3>
        <section>
            <div class="small">
                <p>用构造函数创建出来的组件，和用class创建出来的组件，这两种不同的组件之间的本质区别就是：有无state属性！！！</p>
                <div class="tapNav">
                    <div class="tapTop cur">Class组件（有状态组件）</div>
                    <div class="tapTop">普通组件(傻组件)</div>
                </div>
                <div class="tapMain">
                    <div class="tapSection">
                        <p>在class创建的组件中，必须定义一个render函数;在render函数中，必须返回一个null或者符合规范的虚拟DOM元素</p>
                        <pre class="text4"><code class="js"></code></pre>
                        <h5 class="subtitle">组件通信-父向子传递</h5>
                        <p>在constructor中接收父组件传递的值。还要记得必须写super(props)因为组件是继承过来的</p>
                        <pre class="text6"><code class="js"></code></pre>
                        <h5 class="subtitle">Class组件的私有状态(私有数据)</h5>
                        <p>Class组件称之为有状态组件。即组件的私有数据的存放位置。相当于Vue组件的data选项。 它的存放位置在constructor中的super(props)下面。 状态存放是通过this.state = {} 来存储。 修改状态 是通过this.setState({})相当于小程序的修改，是异步的方法</p>
                        <pre class="text7"><code class="js"></code></pre>
                        <p>在调用setState函数之后，React会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。经过调和过程，React会以相对高效的方法根据新的状态构建React元素树并且着手重新渲染整个UI界面。React得到元素树之后，React会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React能够相对精确的知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p>
                    </div>
                    <div class="tapSection">
                        <p>通过构造函数定义组件</p>
                        <pre><code class="js">function Name(){ return null }</code></pre>
                        <p>使用组件</p>
                        <pre><code class="js">&lt;Name>&lt;/name></code></pre>
                        <pre class="text3"><code class="js"></code></pre>
                        <ol>
                            <li>组件必须有返回值；若不呈现任何内容，则返回空值</li>
                            <li>在定义组件时组件名称必须以大写开头。</li>
                        </ol>
                        <h5 class="subtitle">组件通信-父向子传递</h5>
                        <p>父组件通过标签属性来传递。子组件通过构造函数中的形参来进行接收。</p>
                        <pre class="text5"><code class="js"></code></pre>
                    </div>
                </div>
            </div>
            <div class="small">
                <h4>组件默认值和数据类型验证</h4>
                <h5 class="subtitle">给组件设置默认属性：</h5>
                <p>defaultProps是一个静态属性前面 要加static</p>
                <h5 class="subtitle">类型校验</h5>
                <p>需要先安装yarn add prop-types --save 也是静态属性前面要加static ReactTypes这个名字是为了能区分.</p>
                <a class="btns" href="javascript:;">代码</a>
                <pre class="text15"><code class="js"></code></pre>
            </div>
            <div class="small">
                <h5 class="subtitle">Fragments</h5>
                <p>Fragments 可以聚合一个子元素列表，并且不在DOM中增加额外节点。</p>
            </div>
        </section>
    </div>
    <div class="item">
        <h3>React 组件样式管理</h3>
        <section>
            <div class="small">
                <h4>样式组件行内式</h4>
                <pre class="text8"><code class="js"></code></pre>
                <p>style属性的值不可以书写字符串，改写一个对象。在style属性上，我们第一个大括号是JS语法符号。内部的大括号则是js对象。</p>
            </div>
            <div class="small">
                <h4>行内式的另一种写法</h4>
                <pre class="text9"><code class="js"></code></pre>
            </div>
            <div class="small">
                <h4>css模块化</h4>
                <p>CSS模块就是所有的类名都只有局部作用域的CSS文件。</p>
                <p>修改webpack.config.js</p>
                <pre><code class="js">{test:/\.css$/,use:['style-loader',{loader:'css-loader', options:{
            modules:{
                localIdentName:'[name]__[local]--[hash:5]'}  //随机字符串规则化，name表示是css文件名称，local表示是原本的类名，hash是根据文件生成的随机字符串。
            } //将样式模块化
            sourceMap:true, //样式映射定位
     }]},</code></pre>
                <p>修改commet.js组件。</p>
                <pre><code class="js">import style from './commet.css'</code></pre>
                <p>给标签添加类名</p>
                <pre><code class="js">className={style.className}</code></pre>
            </div>
        </section>
    </div>
    <div class="item">
        <h3>React生命周期</h3>
        <section>
        <p>在组件创建、到加载到页面上运行、以及组件被销毁的过程中，总是伴随着各种各样的事件，这些在组件特定时期，触发的事件，统称为 组件的生命周期。</p>
        <h5 class="subtitle">React组件的生命周期分为三大阶段</h5>
        <ol>
            <li>组件创建阶段:组件创建阶段的生命周期函数，有一个显著的特点：创建阶段的生命周期函数，在组件的一辈子中，只执行一次；
                <ol>
                    <li>constructor 组件初始时自动调用</li>
                    <li>componentWillMount: 组件将要被挂载，此时还没有开始渲染虚拟DOM</li>
                    <li>render：第一次开始渲染真正的虚拟DOM，当render执行完，内存中就有了完整的虚拟DOM了 render(){}渲染成虚拟dom，将来可以用来去和老的虚拟dom进行diff算法。 页面中没有效果</li>
                    <li>componentDidMount: 组件完成了挂载，此时，组件已经显示到了页面上，当这个方法执行完，组件就进入了 运行中的状态</li>
                </ol>
            </li>
            <li>组件运行阶段:也有一个显著的特点，根据组件的state和props的改变，有选择性的触发0次或多次；
                <ol>
                    <li>componentWillReceiveProps: 组件将要接收新属性，此时，只要这个方法被触发，就证明父组件为当前子组件传递了新的属性值；可以接收新的props和state，但是并未更新</li>
                    <li>shouldComponentUpdate: 组件是否需要被更新，此时，组件尚未被更新，可以接收新的props和state，但是并未更新 </li>
                    <li>componentWillUpdate: 组件将要被更新，此时，尚未开始更新，可以接收新的props和state，内存中的虚拟DOM树还是旧的 render: 此时state 和 props,已经是最新的，被更新的同时 重新渲染一棵内存中的 虚拟DOM树，当 render 调用完毕，内存中的旧DOM树，已经被新DOM树替换了！此时页面还是旧的</li>
                    <li>componentDidUpdate: 此时，页面又被重新渲染了，state 和 虚拟DOM 和 页面已经完全保持同步</li>
                </ol>
            </li>
            <li>组件销毁阶段：一辈子只执行一次；
                <p>componentWillUnmount: 组件将要被卸载，此时组件还可以正常使用；</p>
            </li>
        </ol>
            <div class="bigimg"><img src="images/react/reactCircle.jpg" alt=""></div>
            <a class="bntTap" href="javascript:;">代码</a>
            <div class="tapNav">
                <div class="tapTop cur">Life.js</div>
                <div class="tapTop">LifeCircle.js</div>
            </div>
            <div class="tapMain">
                <div class="tapSection">
                    <pre class="text10"><code class="js"></code></pre>
                </div>
                <div class="tapSection">
                    <pre class="text11"><code class="js"></code></pre>
                </div>
            </div>
            <ol>
                <li>数据更新必须是通过this.setState()来进行更新数据，不可以直接对数据进行类似this.state.num++这种前置++或者后置++来实现效果。</li>
                <li>shouldComponentUpdate ： 必须在这个生命周期中返回true或者false。返回true表示会更新，如果返回false则不更新。</li>
                <li>通过ReactDOM的unmountComponentAtNode来卸载组件。不过这里卸载组件只能卸载通过ReactDOM.render加载的组件。</li>
                <li>在render,shouldComponentUpdate,componentWillUpdate,componentDidUpdate中调用setState时，会导致死循环，最终报错。</li>
                <li>componentWillMount，componentDidMount，componentWillReceiveProps可以更新数据</li>
                <li>对于ajax而言，应该在componentDidMount进行。因为React下一代调用算法Fiber会通过开始或停止渲染的方式优化应用性能，其会影响到componentWillMount的触发次数。对于componentWillMount这个生命周期函数的嗲用次数会不确定，React可能会多次频繁调用componentWillMount。如果我们将AJAX请求放到componentWillMount函数中，那么显而易见其会被触发多次，自然也就不是最好的选择。而且在React-Native中是没有componentWillMount 这个生命周期的。</li>
            </ol>
        </section>
    </div>
    <div class="item">
        <h3>React双向数据绑定</h3>
        <section>
            <div class="small">
                <p>refs是React提供给我们的安全访问DOM元素或者某个组件实例的句柄。对组件身上添加 ref属性，且设置值a。在setState功能中使用 this.refs.a就可以直接获取元素。</p>
                <pre class="text12"><code class="react"></code></pre>
<p>可以为元素添加ref属性然后在回调函数中接受该元素在DOM树中的句柄，该值会作为回调函数的第一个参数返回：</p>
                <pre class="text23"><code class="react"></code></pre>
            <a href="javascript:;" class="bntTap">todolist例子</a>
            <div class="tapNav">
                <div class="tapTop cur">Commet.js组件</div>
                <div class="tapTop">Item.js组件</div>
            </div>
            <div class="tapMain">
                <div class="tapSection"><pre class="text13"><code class="js html"></code></pre></div>
                <div class="tapSection"><pre class="text14"><code class="js"></code></pre></div>
            </div>
            </div>
        </section>
    </div>
    <div class="item">
        <h3>组孙级和非父子组件传递数据</h3>
        <section>
            <div class="small">
                <h4>祖孙级传递数据</h4>
                <h5 class="subtitle">context特性</h5>
                <ul>
                    <li>1.给组先级书写一个方法
                    <pre><code class="js">getChildContext(){ return {color:this.state.color}}</code></pre>
                    </li>
                    <li>2.在祖先级使用属性校验规定一下给子组件的数据类型，需要定义一个静态的（static） childContextTypes
                        <pre><code class="js">static childContextTypes = {color:ReactProps.string}</code></pre>
                    </li>
                    <li>3.孙子组件，使用之前先检验一下数据类型，需要定义一下
                        <pre><code class="js">static contextTypes = {color:ReactProps.string}</code></pre>
                    </li>
                    <li>4.再使用{this.context.color}</li>
                </ul>
            </div>
            <div class="small">
                <h4>非父子组件通信</h4>
                <p>使用 EventEmitter 模块（npm包 node的基础模块）进行通信。</p>
                <p>安装自定义事件库yarn add enentemitter2(类似vue-bus)</p>
                <a class="btns" href="javascript:;">代码</a>
                <pre class="text16"><code class="js"></code></pre>
            </div>
        </section>
    </div>
    <div class="item">
        <h3>React 路由</h3>
        <section>
            <div class="small">
                <h4>路由基础</h4>
                <pre><code class="nodejs">npm install react-router-dom -S</code></pre>
                <h5 class="subtitle">三个常用的组件</h5>
                <ol>
                    <li>HashRouter/BrowserRouter
                        <ol>
                            <li>HashHistory :  浏览器的url是这样的：/#/user/liuna?_k=adseis
                            <p>使用hashHistory时，因为有 # 的存在，浏览器不会发送request,react-router 自己根据 url 去 render 相应的模块。</p>
                            </li>
                            <li>BrowserHistory : HistoryAPI路由,浏览器的url是这样的：/user/liuna
                            <p>使用browserHistory时，从 / 到 /user/liuna, 浏览器会向server发送request，所以server要做特殊请求，比如用的 express 的话，你需要 handle所有的路由 app.get('*', (req, res) => { ... })，使用了 nginx 的话，nginx也要做相应的配置。</p>
                            </li>
                        </ol>
                    </li>
                    <li>Link
                        <p>有to属性是跳转到哪个页面 exact表示严格</p>
                    </li>
                    <li>Route
                        <p>路由的匹配规则、占位显示</p>
                        <ol>属性:
                            <li>path</li>
                            <li>component</li>
                            <li>exact(路由严格模式)</li>
                        </ol>
                    </li>
                </ol>
                <a href="javascript:;" class="btns">代码</a>
               <pre class="text17"><code class="react"></code></pre>
            </div>
            <div class="small">
                <h4>动态路由</h4>
                <ul>路由参数
                    <li>1、注意要添加exact严格模式</li>
                    <li>2、路由参数和vue一样，通过/:name</li>
                    <li>3、组件中使用，是通过this.props.match.params.name</li>
                </ul>
                <a href="javascript:;" class="btns">入口文件main.js</a>
                <pre class="text18"><code class="react"></code></pre>
                <a href="javascript:;" class="btns">news.js组件</a>
                <pre class="text19"><code class="react"></code></pre>
            </div>
            <div class="small">
                <h4>路由导航定位</h4>
                <p>路由导航定位的其实就是页面发生跳转，那么页面中对定的导航链接需要被选定。</p>
                <h5 class="subtitle">利用二级路由实现</h5>
                <a href="javascript:;" class="btns">代码</a>
                <pre class="text20"><code class="react"></code></pre>
                <h5 class="subtitle">使用NavLink组件（比较少用）</h5>
                <pre class="text21"><code class="react"></code></pre>
            </div>
            <div class="small">
                <h4>路由重定向</h4>
                <pre><code class="react">import {Link, Route,Redirect} from "react-router-dom";
 &lt;Redirect to={'/home'} /></code></pre>
                <h5 class="subtitle">Switch路由组件</h5>
                <p>可以理解为Switch其实就和JS中的switch语句类似只会匹配一个。</p>
                <pre class="text22"><code class="react"></code></pre>
            </div>
            <div class="small">
                <h4>路由懒加载</h4>
                <p>路由懒加载的目的是为了让首页加载速度快，其实也是为了按需加载。但官方没有提供，社区中有提供这方面的代码。需要安装lazyload-loader。</p>
                <p>使用方法</p>
                <pre><code class="react">module: {
  rules: [
   {
    test: /\.(js)$/,,
    use: [
     'babel-loader',
     'lazyload-loader'
    ]
   },</code></pre>
                <p>在业务代码中</p>
                <pre><code class="react">// 使用lazy! 前缀 代表需要懒加载的Router
import Shop from 'lazy!./src/view/Shop';
// Router 正常使用
&lt;Route path="/shop" component={Shop} /></code></pre>
            </div>
        </section>
    </div>
</article>
</body>
</html>
<script src="js/page.js"></script>
<script src="js/frame/react.js"></script>
<script src="js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

